#!/usr/bin/python
#This python program creates an xml digest of all items in a given OCFA database. 
#The program takes two command line arguments:
# * The name of the database
# * The path of an xml file containing meta data to ignore while creating the dump.
#This program is meant to be used as half of a regression testing tool for OCFA.
#First this program can be used to create a reference digest for a set of items.
#After changes have been made to any part of OCFA, this program again can be used to
#make a comparison dump of those same items.
#A second tool can than be used to generate reports on the differences between the
#reference dump and the comparison dump.
import sqlobject as SO
import xml.etree.ElementTree
import sys

#We need to initialize some global database object stuff before we can define our auto
#database induced sqlobject clases. 
if len(sys.argv) < 2:
  print "No database/case name given"
  sys.exit(1)
case=sys.argv[1]
dburi="postgres://ocfa:ocfa@127.0.0.1/" + case;
connection=SO.connectionForURI(dburi)
SO.sqlhub.processConnection=connection


#The following 3 classes are auto induced from our database and
#represent single tables in the OCFA database.

class item(SO.SQLObject):
  class sqlmeta:
    fromDatabase = True
    idName = "itemid"

class metadatainfo(SO.SQLObject):
  class sqlmeta:
    fromDatabase = True
    idName = "metadataid"

class metastoreentity(SO.SQLObject):
  class sqlmeta:
    fromDatabase = True


#A simple class for holding meta data descriptions.
class SimpleMeta:
  def __init__(self,module,name,val,stype,mtype):
    self.module=module
    self.key=name
    self.val=val
    self.stype=stype
    self.mtype=mtype
    if (stype == "datetime"):
      self.val=val[:val.rfind(':')]
  def __eq__(self,other):
    if (self.key == other.key) and (self.val == other.val) and (self.stype==other.stype) and (self.mtype == other.mtype) and (self.module == other.module):
      return True
    else:
      return False
  def __ne__(self,other):
    if self == other:
      return False
    return True
  def __hash__(self):
    hstr=self.mtype + "." + self.stype + "." + self.key + ":" + self.val + ":" + self.module
    return hash(hstr) 
  def add_to_tree(self,tree): #This method adds the SimpleMeta object as an xml element to the given xml property tree.
     meta=xml.etree.ElementTree.Element('meta')
     meta.set("module",self.module)
     meta.set("containertype",self.mtype)
     meta.set("scalartype",self.stype)
     meta.set("metaname",self.key)
     meta.text = self.val
     tree.append(meta)
  def sametype(self,other): #This method checks if a given SimpleMeta is of the same type as this one, that is, its the same except for the actual vallue.
    if (self.key == other.key) and (self.module == other.module) and (self.stype==other.stype) and (self.mtype == other.mtype):
      return True
    return False

#This class is a wrapper for an evidence XML as found in the metastoreentity table.
class OcfaXml:
  def __init__(self,elementtree):
    self.etree=elementtree
    self.isfile=False
    if 'sha' in self.etree.keys():
      self.isfile=True
    locel=self.etree.find('location')
    self.name=locel.attrib['name']
    self.location=locel.text
    if self.name == None:
      self.name=""
    if self.location ==None:
      self.location=""
    firstjob=self.etree.find('job')
    #We can be a node in a tree generated by our creator module.
    #If we are, our children inside the first job constitute the branches below us as node.
    self.branches=set()
    childevidences=firstjob.findall("childevidence")
    for childevidence in childevidences:
      self.branches.add(childevidence.attrib['evidenceid'])
    #Create a temporary set with all our children.
    allbranches=set()
    jobs=self.etree.findall('job')
    for job in jobs:
      childevidences=job.findall("childevidence")
      for childevidence in childevidences:
        allbranches.add(childevidence.attrib['evidenceid'])
    #Our real children are those that arn't branches.
    self.children=allbranches.difference(self.branches)
  def isfile(self):
    return self.isfile
  def sha1(self):
    if self.isfile:
      return self.etree.attrib["sha"]
    return ""
  def getlocation(self):
    return self.location
  def getname(self):
    return self.name
  def getbranches(self):
    return self.branches
  def getchildren(self):
    return self.children
  def getroute(self): #This method returns a string describing what modules the evidence traversed.
    jobs=self.etree.findall('job')
    route=""
    count=0
    for job in jobs:
      jobmodule=job.find("moduleinstance")
      if jobmodule != None:
        modulestring=jobmodule.attrib["module"]
        if modulestring != "router": #We are not interested in the router, only normal modules.
          if (count > 0):
            route = route + "-"
          route=route + modulestring
      count=count+1
    return route 
  def getmeta(self,metafilter): #Retreive all meta one by one (generator)
    jobs=self.etree.findall('job')
    for job in jobs:
      jobmodule=job.find("moduleinstance")
      if jobmodule != None:
         modulestring=jobmodule.attrib["module"]
         metalist=job.findall('meta')
         for meta in metalist:
           name=meta.attrib["name"]
           mtype=meta.attrib["type"]
           scalars=meta.findall('scalar')
           for scalar in scalars:
             val=scalar.text
             stype=scalar.attrib["type"]
             metaobj=SimpleMeta(modulestring,name,val,stype,mtype)
             if metafilter(metaobj):
               yield metaobj

#Simple data class for evidence.
class SimpleEvidence:
  def __init__(self,ocfaxml,parent,relpath,metafilter):
    if (parent == ""):
      self.isderived=False
    else:
      self.isderived=True
      self.parent=parent
    self.hash=ocfaxml.sha1()
    self.relpath=relpath
    self.route=ocfaxml.getroute()
    self.ocfaxml=ocfaxml
    self.metafilter=metafilter
  def __hash__(self):
    myhash=self.hash + ":" + self.relpath
    if self.isderived:
      myhash=myhash+"<"+self.parent
    return hash(myhash)
  def __eq__(self,other):
    if (self.isderived == other.isderived) and (self.parent == other.parent) and (self.hash == other.hash) and (self.replath == other.relpath):
      return True
    else:
      return False
  def __ne__(self,other):
    if self == other:
       return False
    else:
       return True
  def add_to_tree(self,tree): #Add this SimpleEvidence as XML elements to a given element tree. 
     file=xml.etree.ElementTree.Element('file')
     file.set("hash",self.hash)
     file.set("relpath",self.relpath)
     file.set("route",self.route)
     if self.isderived:
       file.set("parent",self.parent)
     #Extract allrelevant  meta from the ocfa xml and add it to the element tree,
     for meta in self.ocfaxml.getmeta(self.metafilter):
       meta.add_to_tree(file)   
     tree.append(file)

#Helper class for talking to the OCFA database.
class OcfaDb:
  #Helper method for converting an evidence id (for the currently set item) to a metadata id.
  def xmlid(self,eid):
    subnodequery="evidence='" + str(eid) + "' AND itemid=" + str(self.topitem)
    subnodes=metadatainfo.select(subnodequery)
    subnodeid=0
    for subnode in subnodes:
      subnodeid=subnode.id
    return subnodeid
  #Helper function for converting a metadata id into an element tree representing the xml meta store entity.
  def xmlelementtree(self,nodeid):
    entquery="id = " + str(nodeid)
    entities=metastoreentity.select(entquery)
    xmlstring=""
    for entity in entities:
      xmlstring=entity.content
    if (xmlstring==""):
      return
    return xml.etree.ElementTree.fromstring(xmlstring)
  #Helper method for switching items.
  def switch_item(self,item):
    self.topitem=item
    self.topnodeid=self.xmlid("0")
    self.topxml=self.xmlelementtree(self.topnodeid)
  def next_item(self):
    itemlist=item.select()
    for myitem in itemlist:
      self.switch_item(myitem.id)
      yield self.topitem
  #Get the element tree for the item its 
  def topevidence(self):
    return self.topxml
  #Get the element tree for a non root node evidence with a given evidence id.
  def subxmlelementtree(self,eid):
    subnodeid=self.xmlid(eid)
    return self.xmlelementtree(subnodeid)

#A classe for walking the metadata database table using the tree structure to infer the tree.
class TreeWalker:
  def __init__(self,ocfadb,basepath,metafilter):
    self.ocfadb=ocfadb
    self.basepath=basepath
    self.metafilter=metafilter
  #Add this node to the output xml property tree.
  def add_node(self,ocfaxml,parenthash,evidenceset):
    if (ocfaxml.isfile):
      location=ocfaxml.getlocation()
      name=ocfaxml.getname()
      fullpath=location + "/" + name
      relpath=fullpath[len(self.basepath)+1:]
      sevidence=SimpleEvidence(ocfaxml,parenthash,relpath,self.metafilter)
      evidenceset.add(sevidence)
  #Walk all of this node its branches, but not its children.
  def walkbranches(self,ocfaxml,parenthash,evidenceset):
    if (ocfaxml.isfile):
      #Update the parent hash if needed.
      parenthash=ocfaxml.sha1()
    for branch in ocfaxml.getbranches():
      #For each branch node, extract an OcfaXml object.
      branchnode=OcfaXml(self.ocfadb.subxmlelementtree(branch))
      #Add the node itself to the property tree
      self.add_node(branchnode,parenthash,evidenceset)
      #Than walk all branches of the node.
      self.walkbranches(branchnode,parenthash,evidenceset)
  #Walk this node and all its children but not its branches.
  def walkchildren(self,ocfaxml,parenthash,evidenceset):
    if (ocfaxml.isfile):
      #Update the parent hash if needed.
      parenthash=ocfaxml.sha1()
    for child in ocfaxml.getchildren():
      #For each child node, extract an OcfaXml object.
      childnode=OcfaXml(self.ocfadb.subxmlelementtree(child))
      #Add the node itself to the property tree
      self.add_node(childnode,parenthash,evidenceset)
      #We do walk the branches of our children, just not our own branches.
      self.walkbranches(childnode,parenthash,evidenceset)
      #Also walk the children of our children
      self.walkchildren(childnode,parenthash,evidenceset)  
    #also walk the children of our branches.
    for branch in ocfaxml.getbranches():
      branchnode=OcfaXml(self.ocfadb.subxmlelementtree(branch))
      self.walkchildren(branchnode,parenthash,evidenceset)   
  def __call__(self,ocfaxml,inputset,outputset):
    #Fists add the top node itself in case its a file
    self.add_node(ocfaxml,"",inputset)
    parenthash=ocfaxml.sha1()
    #Extract the input set and derived meta data that comes with that.
    self.walkbranches(ocfaxml,parenthash,inputset)
    #Extract the output set and derived meta data that comes with that.
    self.walkchildren(ocfaxml,parenthash,outputset)
    
#Classe that holds the ignore filter for ignoring meta data that is non constant between runs.
class IgnoreFilter:
  def __init__(self,file):
    self.nodes=set()
    if file != "":
      #Parse the config xml file.
      tree=xml.etree.ElementTree.parse(file)
      metalist=tree.findall("meta")
      self.nodes=set()
      for metael in metalist:
        module=metael.attrib["module"]
        name=metael.attrib["metaname"]
        val=""
        stype=metael.attrib["scalartype"]
        mtype=metael.attrib["containertype"] 
        metaobj=SimpleMeta(module,name,val,stype,mtype)
        self.nodes.add(metaobj)
  def __call__(self,meta):
    #Compare our argument with each of the filters.
    for reference in self.nodes:
      if meta.sametype(reference):
        return False
    return True

#Class for dumping single items to an xml file.
class ItemDumper:
  def __init__(self,regressiondb,metafilter,case):
    self.item=item
    self.regressiondb=regressiondb
    self.metafilter=metafilter
    self.case=case
  def __call__(self,item):
    print "Dumping database digest for item ", item
    topevidence=self.regressiondb.topevidence()
    if topevidence == None:
      return
    ocfaxml=OcfaXml(topevidence)
    treewalker=TreeWalker(self.regressiondb,ocfaxml.getname(),self.metafilter)
    inputset=set()
    deriveset=set()
    treewalker(ocfaxml,inputset,deriveset)
    top=xml.etree.ElementTree.Element('itemdigest')
    root=xml.etree.ElementTree.Element('inputfiles')
    top.append(root)
    for input in inputset:
      input.add_to_tree(root)
    deriveroot=xml.etree.ElementTree.Element('derivedfiles')
    top.append(deriveroot)
    for derived in deriveset:
      derived.add_to_tree(deriveroot)
    report=xml.etree.ElementTree.tostring(top, encoding='utf-8')
    outputfilename= "itemdigest_" +  self.case + "_item" + str(regressiondb.topitem) + ".xml"
    f=open(outputfilename,"w")
    f.write(report)

ignorefile=""
if len(sys.argv) > 2:
  ignorefile=sys.argv[2]
metafilter=IgnoreFilter(ignorefile)

regressiondb = OcfaDb()
dump=ItemDumper(regressiondb,metafilter,case)
for item in regressiondb.next_item():
  dump(item)
